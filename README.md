# Sockets and routes with python.

## Данный проект представляет собой путь ознакомления с сокетами и роутингом на python.

---

Задача заключается в том, что сервер должен получить от пользователя / клиента какой-то запрос, прочитать этот запрос, выяснить что клиент хочет сделать, какие методы клиент использует и на какую страницу направляется. В зависимости от того, что запросил пользователь / клиент, сервер должен сгенерировать ему ответ.

---
### Теория

Использовать буду протокол **http**, который в свою очередь базируется на двух протоколах:
**tcp** - *transmition control protocol* (port). Отвечает за корректность в получении и отправки пакетов. Порты нужны для того, чтобы несколько приложений могли работать с одним ip, при этом не занимая весь туннель.
**ip** - *internet protocol* (ip address).
**ip address:port** - эта пара называется сокетом (socket).

**Клиент** - тот, кто делает запрос.
**Сервер** - тот, кто принимает запрос и как-то его обрабатывает.

---

1. Я создал скрипт **main.py** и сделал *import socket*.

2. Записываю конструкцию:

if __name__ == '__main__':

она необходима для того чтобы при запуске файла из консоли выполнялось условие указанное в теле данной конструкции. В случае если наш файл main.py будет куда-то импортирован, то условие выполняться не будет, следовательно выполнение кода не произойдёт.

3. В данной конструкции указываю метод **def run**() и создаю данный метод. Он будет отвечать за соединения клиента с сервером.

Первым делом нужно создать субъект, который будет принимать запрос, назову его **server_socket**.

*AF_INET* (Adress Famiily, INET - ipv4)
*SOCK_STREAM* (TCP)

4. Далее связываю данного субъекта с конкретным адресом с помощь метода **.bind**(), который принимает конкретный кортеж. В моем случае, ip адрес - localhost, а порт - 5000. 

5. Настраиваем наш сервер на прослушивание указанного выше порта. Для этого существует метод **.listen**().

6. Поскольку данное взаимодествие между клиентом и сервером длящийся процесс, то я использую бесконечный цикл **while True**.

7. Для того, чтобы созданный сокет что-то получил, существует метод **.accept**(). Данный метод возвращает кортеж, который мне нужно распаковать.
**Первый** элемент кортежа - сокет (*client_socket*) того, кто отсылает запрос.
**Второй** - адрес (*addr*) того, кто отсылает запрос.

**.accept**() возвращает нам сокет со стороны клиента.

8. Для того, чтобы увидеть, что мне прислал клиент, создаю переменную **request**. Модуль .recv() означает recieve, а 1024 - количество байт.

9. Теперь мне нужно ответить клиенту на его запрос. Использую для этого метод **.sendall**('Request accepted!'), особенность в том, что клиентская сторона не понимает строковые значения, так что мне нужно закодировать ответ с помощью метода **.encode**(), который возвращает тип данных bytes. После чего закрывает соединение с помощью метода **.close**().

10. На данный момент можно запустить в командной строке скрипт, для этого использую команду python3 main.py и открываю в браузере адрес localhost:5000.

В данном случае, в выводимом в консоле коде мы можем увидеть метод **GET**, куда обращается клиент, в данном случае обращение происходит к корневому url **/**, какой использует протокол **HTTP/1.1**.

11. Есть интересная особенность. Если на данном этапе отключить сервер и попытаться запустить его заново, то мы столкнемся с ошибкой, сообщающей о том, что данный *Address already in use*. Суть заключается в специальном защитном механизме, у котором таймаут примерно на 1.5 минуты, который необходим для обеспечения доставки пакетов.

Обойти данную особенность можно путём установки определенных параметров перед методом **.bind**().
Обращаюсь к нашему сокету с помощью метода **.setsockopt**() - set socket options, который принимает три аргумента. **Первое** - на каком уровне данные опции устанавливаются, SOL_SOCKET - socket level. **Второе** - SO_REUSEADDR - socket option reuse address, допуск повторного использования адреса. **Третье** - 1, ставим данный параметр в True.

12. Для того, чтобы отвечать пользователю определенным образом, создают переменную **response**. Она будет принимать результат работы функции **generate_response**(), которая в свою очередь в виде атрибутов получает *request.decode('utf-8')*.

13. Создаю функцию **generate_response**(*request*).
В теле функции нам необходимо распарсить получаемый из **request** кортеж на **method** (*HTTP метод*) и **url** (*url запрос*). 

14. Создаю функцию **parse_request**(*request*).
В буферную переменную записываем значение полученное от разделения **request.split**(' '). Получаю нулевый элемент [0] - *method*, а первый элемент [1] - *url*. Функция возвращает кортеж вида (method, url).

15. Ответ клиенту будет состоять из двух частей: **header**(*заголовка*) и **code**(*тела*). Нужно будет провести определенные проверки на то, какой ответ будет отправлен клиенту, в зависимости от запроса, существования страницы, доступность запроса и др.
Для этого у меня создана функция **generate_header**(*method*, *url*). В данной функции проведу проверки на то, чтобы метод соответствовал методу 'GET', а url попадал в список существующих **URLS**. Для отделения заголовка от тела использую конструкцию **\n\n**.

В функции **generate_response**() указываю в return полученные **headers.encode**().

Словарь URLS будет содержать в себе список доступных страниц. '/' - для корневой, '/test' - для тестовой.

16. После проделанной работы наши заголовки начали попадать в переменную **response**, так как она записывает в себя работу функции **generate_response**(). Теперь в **client_socket.sendall**() можно передать переменную **response** вместо изначального значения.

17. Теперь есть возможность протестировать и закрепить полученные результаты. Запускаю сервер через **python3 main.py**, перехожу на *localhost:5000*. В форме кода страница (F12) -> Network -> All, при переходе на корневую страницу получаю **200 ОК** в ответе от сервера, при переходе на /test - **200 OK**, при переходе на рандомную не прописанную страницу - **404**.

18. Генерация тела (code). Записываться будет в переменную body по результатам работы функции **generate_content**(code, url).
Функция **generate_content**() будет отвечать за создание тела ответа. В ней будет происходить отсеивание ошибок, и при корректном отображении в return будет попадать страница из URLS с передаваемым в атрибут значением url. С помощью метода .format вывожу получаемый результат в отформатированном виде.

19. На данном этапе я создал файл **views.py** и папку **templates**, для более углубленной проверки фукнционала. Во views будет две функции: **def index**() - ссылается на *templates/index.html*, а **def test**() - ссылается на *templates/test.html*. И 

Обязательно необходимо сделать **import views**, чтобы можно было использовать созданные views внутри main.py

Теперь в словаре URLS можно избежать использования кода, и можно напрямую вызывать ранее созданные views.

Так же в функции **generate_content**() в *return* можно убрать созданную ранее конструкции и использовать **URLS[url]**(), скобочки в данном случае необходимы, потому что полученный ключ должен вызываться как функция.

## Заключение.
Таким образом реализуется маршрутизация запросов. Общие идеи актуальные для фреймворков типа Flask и Django. 
Разница в том, что во **Flask** используется словарь, который генерируется в классе Flask, и генерируется с помощью *деократоров*, *например: @app.route('/')*. Аргумент для декоратора становится ключом, а декорируемая функция становится значением этого ключа. 
В **Django** используется другой механизм, в нем используется список. В переменной urlpatterns становится списком, и каждый элемент этого списка это вызов функции url или path('/', index), принимающей первым аргументом url, а вторым - функцию (view) которая обрабатывает запрос по указанному url.